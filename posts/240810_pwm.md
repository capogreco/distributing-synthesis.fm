---
title: Pulse Width Modulation
published_at: 2024-08-10
snippet: ... with Audio Worklet.
disable_html_sanitization: true
allow_math: true
---

<div id="worklet_example"></div>

```js
// worklets/pwm.js
class PWMProcessor extends AudioWorkletProcessor {

   constructor ({ processorOptions: { sample_rate } }) {
      super ()
      this.alive = true
      this.phase = Math.random ()
      this.inc   = 1 / sample_rate
   }

   static get parameterDescriptors () {
      return [ 
         { name: 'freq', defaultValue: 220 },
         { name: 'duty_cycle',  defaultValue: 0.5 },
      ]
   }

   process (_inputs, outputs, parameters) {
      const out = outputs[0][0]

      for (let frame = 0; frame < out.length; frame++) {
         let sig = 0
         const freq = deparameterise (parameters.freq, frame)
         const duty_cycle = deparameterise (parameters.duty_cycle, frame)

         sig = this.phase < duty_cycle ? 1 : -1

         this.phase += this.inc * freq
         this.phase %= 1
         out[frame] = sig
      }

      return this.alive
   }
}

registerProcessor ('pwm', PWMProcessor)

function deparameterise (arr, ind) {
   return arr[(1 != arr.length) * ind]
}
```

```html
<div id="worklet_example"></div>

<script type="module">
   const div  = document.getElementById ("worklet_example")
   div.width  = div.parentNode.scrollWidth
   div.style.height = `${ div.width * 9 / 32 }px`
   div.style.backgroundColor = `tomato`
   div.style.textAlign       = 'center'
   div.style.lineHeight      = div.style.height
   div.style.fontSize        = `${ div.width / 20 }px`
   div.style.fontWeight      = 'bold'
   div.style.fontStyle       = 'italic'
   div.style.color           = 'white'
   div.style.userSelect      = 'none'
   div.innerText = `CLICK TO INITIALISE AUDIO`

   const audio_context = new AudioContext ()
   audio_context.suspend ()

   const graph = {}
   let pointer_down = false
   let cool_down = false

   async function init_audio () {
      await audio_context.resume ()
      await audio_context.audioWorklet.addModule (`worklets/pwm.js`)

      graph.pwm = new AudioWorkletNode (audio_context, `pwm`, {
         processorOptions: {
            sample_rate: audio_context.sampleRate
         }
      })
      graph.pwm.connect (audio_context.destination)

      graph.freq = await graph.pwm.parameters.get (`freq`)
      graph.duty_cycle = await graph.pwm.parameters.get (`duty_cycle`)

      div.style.backgroundColor = `limegreen`
      div.innerText = `AUDIO CONTEXT IS ${ audio_context.state.toUpperCase () }`
   }

   function point_phase (e) {
      const { target: { 
         offsetLeft, offsetTop, offsetWidth, offsetHeight 
      } } = e

      const abs = {
         x: e.clientX ? e.clientX : e.touches[0].clientX,
         y: e.clientY ? e.clientY : e.touches[0].clientY
      }

      const x = (abs.x - offsetLeft) / offsetWidth
      const y = (abs.y - offsetTop)  / offsetHeight

      return { x, y }
   }

   function prepare_param (p, now) {
      p.cancelScheduledValues (now)
      p.setValueAtTime (p.value, now)
   }

   function prepare_params (a, now) {
      a.forEach (p => prepare_param (p, now))
   }

   div.onpointerdown = async e => {
      if (audio_context.state != `running`) {
         await init_audio ()
      }

      div.style.backgroundColor = `limegreen`

      const now = audio_context.currentTime
      prepare_params ([ graph.freq, graph.duty_cycle ], now)
      
      const f = 220 * (2 ** point_phase (e).x)
      graph.freq.exponentialRampToValueAtTime (f, now + 0.3)
      
      graph.duty_cycle.linearRampToValueAtTime (0.2, now + 0.1)

      pointer_down = true
   }

   div.onpointermove = e => {

      if (!pointer_down || cool_down) return

      const now = audio_context.currentTime
      const f = 220 * (2 ** point_phase (e).x)

      prepare_params ([ graph.freq, graph.duty_cycle ], now)
      graph.freq.exponentialRampToValueAtTime (f, now + 0.1)
      graph.duty_cycle.linearRampToValueAtTime (point_phase (e).y, now + 0.1)

      cool_down = true
      setTimeout (() => {
         cool_down = false
      }, 100)
   }

   div.onpointerup = e => {

      if (!graph.pwm) {
         console.log (`delaying`)
         setTimeout (div.onpointerup, 100, e)
         return
      }

      const now = audio_context.currentTime
      prepare_params ([ graph.freq, graph.duty_cycle ], now)
      graph.freq.exponentialRampToValueAtTime (16, now + 0.3)
      graph.duty_cycle.linearRampToValueAtTime (0, now + 0.3)

      div.style.backgroundColor = `tomato`

      pointer_down = false
   }

</script>
```

<script type="module">
   const div  = document.getElementById ("worklet_example")
   div.width  = div.parentNode.scrollWidth
   div.style.height = `${ div.width * 9 / 32 }px`
   div.style.backgroundColor = `tomato`
   div.style.textAlign       = 'center'
   div.style.lineHeight      = div.style.height
   div.style.fontSize        = `${ div.width / 20 }px`
   div.style.fontWeight      = 'bold'
   div.style.fontStyle       = 'italic'
   div.style.color           = 'white'
   div.style.userSelect      = 'none'
   div.innerText = `CLICK TO INITIALISE AUDIO`

   const audio_context = new AudioContext ()
   audio_context.suspend ()

   const graph = {}
   let pointer_down = false
   let cool_down = false

   async function init_audio () {
      await audio_context.resume ()
      await audio_context.audioWorklet.addModule (`worklets/pwm.js`)

      graph.pwm = new AudioWorkletNode (audio_context, `pwm`, {
         processorOptions: {
            sample_rate: audio_context.sampleRate
         }
      })
      graph.pwm.connect (audio_context.destination)

      graph.freq = await graph.pwm.parameters.get (`freq`)
      graph.duty_cycle = await graph.pwm.parameters.get (`duty_cycle`)

      div.style.backgroundColor = `limegreen`
      div.innerText = `AUDIO CONTEXT IS ${ audio_context.state.toUpperCase () }`
   }

   function point_phase (e) {
      const { target: { 
         offsetLeft, offsetTop, offsetWidth, offsetHeight 
      } } = e

      const abs = {
         x: e.clientX ? e.clientX : e.touches[0].clientX,
         y: e.clientY ? e.clientY : e.touches[0].clientY
      }

      const x = (abs.x - offsetLeft) / offsetWidth
      const y = (abs.y - offsetTop)  / offsetHeight

      return { x, y }
   }

   function prepare_param (p, now) {
      p.cancelScheduledValues (now)
      p.setValueAtTime (p.value, now)
   }

   function prepare_params (a, now) {
      a.forEach (p => prepare_param (p, now))
   }

   div.onpointerdown = async e => {
      if (audio_context.state != `running`) {
         await init_audio ()
      }

      div.style.backgroundColor = `limegreen`

      const now = audio_context.currentTime
      prepare_params ([ graph.freq, graph.duty_cycle ], now)
      
      const f = 220 * (2 ** point_phase (e).x)
      graph.freq.exponentialRampToValueAtTime (f, now + 0.3)
      
      graph.duty_cycle.linearRampToValueAtTime (0.2, now + 0.1)

      pointer_down = true
   }

   div.onpointermove = e => {

      if (!pointer_down || cool_down) return

      const now = audio_context.currentTime
      const f = 220 * (2 ** point_phase (e).x)

      prepare_params ([ graph.freq, graph.duty_cycle ], now)
      graph.freq.exponentialRampToValueAtTime (f, now + 0.1)
      graph.duty_cycle.linearRampToValueAtTime (point_phase (e).y, now + 0.1)

      cool_down = true
      setTimeout (() => {
         cool_down = false
      }, 100)
   }

   div.onpointerup = e => {

      if (!graph.pwm) {
         console.log (`delaying`)
         setTimeout (div.onpointerup, 100, e)
         return
      }

      const now = audio_context.currentTime
      prepare_params ([ graph.freq, graph.duty_cycle ], now)
      graph.freq.exponentialRampToValueAtTime (16, now + 0.3)
      graph.duty_cycle.linearRampToValueAtTime (0, now + 0.3)

      div.style.backgroundColor = `tomato`

      pointer_down = false
   }

</script>